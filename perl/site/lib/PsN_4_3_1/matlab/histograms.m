clear;

% ---------- Parameters for the plots ----------

rows    = 2;				% Number of rows in each figure
columns = 2;				% Number of columns
bars    = 20;				% Number of histogram bars

only_print = NaN;                       % Use to make the script print
                                        % only one parameter

text_size = 10;                         % Text size in legend and
                                        % on axes

create_emf = 0;				% Create .emf files. Only
                                        % possible on windows.
					
factor_minimization_successful     = 1;	% Condition the graphs on
                                        % the minimization outcome
factor_covariance_step_successful  = 0;	% Condition the graphs on
                                        % the covariance step outcome
factor_no_covariance_step_warnings = 0;	% Condition the graphs on
                                        % the presence of warning
                                        % messages in the
                                        % covariance step
factor_no_estimate_near_boundary   = 1;	% Condition the graphs on
                                        % the presence of parameter
                                        % estimates near boundaries

% The conditioning alternatives above create times-two extra graphs
% per option set to 1. In total, 16 multiples of histograms may be
% created. In reality, some combinations of errors an warnings are
% impossible or very unlikely which reduce the dimensions
% substancially.

confidence_limits = [2.5, 97.5 ];	% The percentiles to get
                                        % bootstrap estimates for

percentile_bca_limit = 100;
% If the number of available bootstrap samples, given the
% conditions specified above, is lower than this value, a normal
% percentile approach is used even if a BCa was requested.

% ---------- Autogenerated code below ----------

use_bca = 1;				% Was a BCa-type of
                                        % bootstrap run?
bs_samples = 2000;			% Number of bootstrap samples
jk_samples = 36;			% Number of (BCa) jackknife samples

col_names = { 'Significant Digits',
	      'OFV',
	      'par1',
	      'par2',
	      'par3',
	      'par4',
	      'par5',
	      'par6',
	      'par7',
	      'par8',
	      'par9' };

fixed_columns = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 ];
same_columns = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

minimization_successful_col    = 2;	% Column number for the
                                        % minimization sucessful flag
covariance_step_successful_col = 3;	% As above for cov-step warnings
covariance_step_warnings_col   = 4;	% etc
estimate_near_boundary_col     = 5;	% etc

not_data_cols = 12;			% Number of columns in the
                                        % beginning that are not
                                        % parameter estimates.

filename = 'bootstrap_rr.csv';

% ---------- End autogenerated code ----------

% The rest of the code does not change between runs

bootstrap_log = csvread(filename);

[junk, n_columns] = size(fixed_columns);

use_rows     = ones(bs_samples,1);
combinations = [NaN];
comb_names   = {NaN};
short_names   = {NaN};
tmp = [];
tmp_comb  = [];
tmp_short  = {};
tmp_names = {};

% Create the conditioned (sub)data sets from the bootstrap data
if( factor_minimization_successful )
  tmp(:,1) = bootstrap_log(2:bs_samples+1,minimization_successful_col) == 1;
  tmp(:,2) = bootstrap_log(2:bs_samples+1,minimization_successful_col) == 0;
  use_rows = tmp;
  combinations = [1,0];
  comb_names   = {'minimization_successful=1','minimization_successful=0'};
  short_names   = {'m1','m0'};
end
tmp_comb = [];
tmp_short  = {};
tmp_names = {};
if( factor_covariance_step_successful )
  [a,b] = size( use_rows );
  for i = 1:b,
    tmp(:,(i-1)*2+1) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,covariance_step_successful_col) == 1);
    tmp(:,(i-1)*2+2) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,covariance_step_successful_col) == 0);
    tmp_comb(:,(i-1)*2+1) = [combinations(:,i);1];
    tmp_comb(:,(i-1)*2+2) = [combinations(:,i);0];
    n1 = {'covariance_step_successful=1'};
    n2 = {'covariance_step_successful=0'};
    tmp_names(:,(i-1)*2+1) = [comb_names(:,i);n1];
    tmp_names(:,(i-1)*2+2) = [comb_names(:,i);n2];
    tmp_short(:,(i-1)*2+1) = [short_names(:,i);{'c1'}];
    tmp_short(:,(i-1)*2+2) = [short_names(:,i);{'c0'}];
  end
  use_rows     = tmp;
  combinations = tmp_comb;
  comb_names   = tmp_names;
  short_names  = tmp_short;
end
tmp_comb = [];
tmp_short  = {};
tmp_names = {};
if( factor_no_covariance_step_warnings )
  [a,b] = size( use_rows );
  for i = 1:b,
    tmp(:,(i-1)*2+1) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,covariance_step_warnings_col) == 0);
    tmp(:,(i-1)*2+2) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,covariance_step_warnings_col) == 1);
    tmp_comb(:,(i-1)*2+1) = [combinations(:,i);0];
    tmp_comb(:,(i-1)*2+2) = [combinations(:,i);1];
    n1 = {'covariance_step_warnings=0'};
    n2 = {'covariance_step_warnings=1'};
    tmp_names(:,(i-1)*2+1) = [comb_names(:,i);n1];
    tmp_names(:,(i-1)*2+2) = [comb_names(:,i);n2];
    tmp_short(:,(i-1)*2+1) = [short_names(:,i);{'w0'}];
    tmp_short(:,(i-1)*2+2) = [short_names(:,i);{'w1'}];
  end
  use_rows = tmp;
  combinations = tmp_comb;
  comb_names   = tmp_names;
  short_names  = tmp_short;
end
tmp_comb = [];
tmp_short  = {};
tmp_names = {};
if( factor_no_estimate_near_boundary )
  [a,b] = size( use_rows );
  for i = 1:b,
    tmp(:,(i-1)*2+1) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,estimate_near_boundary_col) == 0);
    tmp(:,(i-1)*2+2) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,estimate_near_boundary_col) == 1);
    tmp_comb(:,(i-1)*2+1) = [combinations(:,i);0];
    tmp_comb(:,(i-1)*2+2) = [combinations(:,i);1];
    n1 = {'estimate_near_boundary=0'};
    n2 = {'estimate_near_boundary=1'};
    tmp_names(:,(i-1)*2+1) = [comb_names(:,i);n1];
    tmp_names(:,(i-1)*2+2) = [comb_names(:,i);n2];
    tmp_short(:,(i-1)*2+1) = [short_names(:,i);{'b0'}];
    tmp_short(:,(i-1)*2+2) = [short_names(:,i);{'b1'}];
  end
  use_rows = tmp;
  combinations = tmp_comb;
  comb_names   = tmp_names;
  short_names  = tmp_short;
end

[a,b] = size( use_rows );
n_runs = sum( use_rows );
orig_est = bootstrap_log(1,not_data_cols+1:not_data_cols+n_columns);
all_data = bootstrap_log(2:bs_samples+1,not_data_cols+1: ...
			 not_data_cols+n_columns);
if use_bca 
	jk_data  = bootstrap_log(bs_samples+3:bs_samples+jk_samples+2, ...
			 not_data_cols+1: not_data_cols+n_columns);
end

% Create directory for figures
mkdir('matlab_plots');
chdir('matlab_plots');

lower = [];
upper = [];
ci = [];
% loop the subsets
for j = 1:b
  % Only those subsets that have some runs are of interest (obviously)
  if n_runs( j ) > 0 
    row = 1;
    col = 1;
    [R,C] = find( use_rows(:,j) );

    % Create subset
    data = all_data(R,:);

    % Calculate the confidence limits according to each method
    if ( use_bca == 1 ) & ( n_runs(j) > percentile_bca_limit )
      [lower(j,:), upper(j,:)] = bca( orig_est, data, jk_data, ...
				      confidence_limits(1),  confidence_limits(2) );
      ci = [ ci, [[combinations(:,j),combinations(:,j)];[ lower(j,:)', upper(j,:)']] ];
    else
      lower(j,:) = prctile(data,confidence_limits(1),1);
      upper(j,:) = prctile(data,confidence_limits(2),1);
      ci         = [ ci, [[combinations(:,j),combinations(:,j)];[ lower(j,:)', upper(j,:)' ]] ];
    end
  end
end

fignum = 1;
% Loop over all parameters
for i = 1:n_columns,
    if fixed_columns( i ) == 1 || ...
        same_columns( i ) == 1 || ...
      ( ~isnan(only_print) && i ~= only_print )
        continue;
    end
    % Loop over the possible subsets
    row = 1;
    col = 1;
    for j = 1:b
        % Only those subsets that have some runs are of interest (obviously)
        if n_runs( j ) > 0
             [R,C] = find( use_rows(:,j) );

%             % Create subset
             data = all_data(R,:);
             data = data(:,i);

%             lower = [];
%             upper = [];
%             % Calculate the confidence limits according to each method
%             if ( use_bca == 1 ) & ( n_runs(j) > percentile_bca_limit )
%                 [lower, upper] = bca( orig_est(i), data, jk_data(:,i), ...
%                     confidence_limits(1),  confidence_limits(2) );
%                 ci = [ ci, [[combinations(:,j),combinations(:,j)];[ lower', upper']] ];
%             else
%                 lower = prctile(data,confidence_limits(1),1);
%                 upper = prctile(data,confidence_limits(2),1);
%                 ci = [ ci, [[combinations(:,j),combinations(:,j)];[ lower', upper' ]] ];
%             end

            if col == (columns+1)
                col = 1;
                row = row + 1;
            end
            if row == (rows+1) || j == 1
                if row == (rows+1)
		    file = strrep( col_names( i ), ' ', '_' );
		    file = strrep( file, '/', '_' );
		    file = strrep( file, '\', '_' );
		    if create_emf == 1 
		        saveas( gcf, cell2mat(file), 'emf' );
		    end
                    saveas( gcf, cell2mat(file), 'epsc2' );
                end
                h_base  = figure;
		set( h_base, 'Visible', 'off' );
                set( h_base, 'PaperType', 'A4');
                set( h_base, 'PaperOrientation', 'landscape');
                set( h_base, 'PaperPosition', [0.634517 0.634517 28.4084 19.715] );

                col = 1;
                row = 1;
            end

            % Prepare plot
            nplot = col+(row-1)*columns;
            subplot(rows, columns, nplot);

            % Create a histogram
            hist(data,bars);
            h = get(gca,'Children');
            %set(h,'EdgeColor','w');
            hold on;

            ax = axis;
            ax_s = ax(2:2:4)-ax(1:2:3);
            ax_n(1:2:3) = ax(1:2:3)-0.01*ax_s;
            ax_n(2:2:4) = ax(2:2:4)+0.01*ax_s;
            axis(ax_n);

            % Add lines for the lower and upper confidence limits as they are
            % determined by the bootstrap
            h = line( [lower(j,i), lower(j,i)], ax(3:4) );
            h = line( [upper(j,i), upper(j,i)], ax(3:4) );

	    if adjust_axes( i ) == 2 && not ( lower(j,i) == upper(j,i) )
	      axis([(lower(j,i)-0.5*abs(upper(j,i)-lower(j,i))), ...
                    (upper(j,i)+0.5*abs(upper(j,i)-lower(j,i))), ...
                    ax(3:4)]);
            end

            % ----------- Add some text and figures ----------

            [LEGH,OBJH,OUTH,OUTM] = legend( sprintf('%14s%5.3g','lower limit = ',lower(j,i)), ...
                sprintf('%14s%5.3g','upper limit = ',upper(j,i)), ...
                sprintf('%14s%5.0f','n = ', n_runs( j ) ), ...
                'Location', 'NorthEast' );
            legend boxoff;
            set( gca, 'FontSize', text_size);
            %      set( OBJH(1), 'HorizontalAlignment', 'right' );
            %      set( OBJH(2), 'HorizontalAlignment', 'right' );
            %      set( OBJH(3), 'HorizontalAlignment', 'right' );
            set( OBJH(4), 'Visible', 'off');
            set( OBJH(5), 'Visible', 'off');
            set( OBJH(7), 'Visible', 'off');

            % Add a title to each plot
            [c1,c2] = size(short_names);
            name = [];
            %      name = [col_names( i ),'-'];
            for k = 1:c1
                name = [ name, short_names(k,j)];
            end
            if( col == 1 && row == 1 )
                title( cell2mat([col_names( i ),{' - '},name]), 'EdgeColor', 'none' );
            else
                title( cell2mat(name), 'EdgeColor', 'none' );
            end

            hold off;
            col = col + 1;
        end
        %   close;
    end

    if adjust_axes( i ) == 1
        plot_children = get( gcf, 'Children' );
        plot_axes = [];
        max_axis = [];
        min_axis = [];
        for j = 1 : length(plot_children)
            if strcmp( get( plot_children(j), 'Type'), 'axes') && ...
		  ~strcmp( get( plot_children(j), 'Tag'), 'legend')
                plot_axes = [plot_axes, plot_children(j)];
                max_axis = max([max_axis;axis(plot_children(j))],[],1);
                min_axis = min([min_axis;axis(plot_children(j))],[],1);
            end
        end
        axis(plot_axes,[min_axis(1),max_axis(2),min_axis(3),max_axis(4)]);
    end

    file = strrep( col_names( i ), ' ', '_' );
    file = strrep( file, '/', '_' );
    file = strrep( file, '\', '_' );
    if create_emf == 1 
        saveas( gcf, cell2mat(file), 'emf' );
    end
    saveas( gcf, cell2mat(file), 'epsc2' );
end
close all;
chdir('..');
save 'matlab_ci.txt' ci -ascii;

% % The rest of the code does not change between runs

% bootstrap_log = csvread(filename);

% [junk, n_columns] = size(fixed_columns);

% use_rows     = ones(bs_samples,1);
% combinations = [NaN];
% comb_names   = {NaN};
% tmp = [];
% tmp_comb  = [];
% tmp_names = {};

% % Create the conditioned (sub)data sets from the bootstrap data
% if( factor_minimization_successful )
%   tmp(:,1) = bootstrap_log(2:bs_samples+1,minimization_successful_col) == 1;
%   tmp(:,2) = bootstrap_log(2:bs_samples+1,minimization_successful_col) == 0;
%   use_rows = tmp;
%   combinations = [1,0];
%   comb_names   = {'minimization_successful=1','minimization_successful=0'};
% end
% tmp_comb = [];
% tmp_names = {};
% if( factor_covariance_step_successful )
%   [a,b] = size( use_rows );
%   for i = 1:b,
%     tmp(:,(i-1)*2+1) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,covariance_step_successful_col) == 1);
%     tmp(:,(i-1)*2+2) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,covariance_step_successful_col) == 0);
%     tmp_comb(:,(i-1)*2+1) = [combinations(:,i);1];
%     tmp_comb(:,(i-1)*2+2) = [combinations(:,i);0];
%     n1 = {'covariance_step_successful=1'};
%     n2 = {'covariance_step_successful=0'};
%     tmp_names(:,(i-1)*2+1) = [comb_names(:,i);n1];
%     tmp_names(:,(i-1)*2+2) = [comb_names(:,i);n2];
%   end
%   use_rows     = tmp;
%   combinations = tmp_comb;
%   comb_names   = tmp_names;
% end
% tmp_comb = [];
% tmp_names = {};
% if( factor_no_covariance_step_warnings )
%   [a,b] = size( use_rows );
%   for i = 1:b,
%     tmp(:,(i-1)*2+1) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,covariance_step_warnings_col) == 0);
%     tmp(:,(i-1)*2+2) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,covariance_step_warnings_col) == 1);
%     tmp_comb(:,(i-1)*2+1) = [combinations(:,i);0];
%     tmp_comb(:,(i-1)*2+2) = [combinations(:,i);1];
%     n1 = {'covariance_step_warnings=0'};
%     n2 = {'covariance_step_warnings=1'};
%     tmp_names(:,(i-1)*2+1) = [comb_names(:,i);n1];
%     tmp_names(:,(i-1)*2+2) = [comb_names(:,i);n2];
%   end
%   use_rows = tmp;
%   combinations = tmp_comb;
%   comb_names   = tmp_names;
% end
% tmp_comb = [];
% tmp_names = {};
% if( factor_no_estimate_near_boundary )
%   [a,b] = size( use_rows );
%   for i = 1:b,
%     tmp(:,(i-1)*2+1) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,estimate_near_boundary_col) == 0);
%     tmp(:,(i-1)*2+2) = use_rows(:,i).*(bootstrap_log(2:bs_samples+1,estimate_near_boundary_col) == 1);
%     tmp_comb(:,(i-1)*2+1) = [combinations(:,i);0];
%     tmp_comb(:,(i-1)*2+2) = [combinations(:,i);1];
%     n1 = {'estimate_near_boundary=0'};
%     n2 = {'estimate_near_boundary=1'};
%     tmp_names(:,(i-1)*2+1) = [comb_names(:,i);n1];
%     tmp_names(:,(i-1)*2+2) = [comb_names(:,i);n2];
%   end
%   use_rows = tmp;
%   combinations = tmp_comb;
%   comb_names   = tmp_names;
% end

% [a,b] = size( use_rows );
% n_runs = sum( use_rows )
% orig_est = bootstrap_log(1,not_data_cols+1:not_data_cols+n_columns);
% all_data = bootstrap_log(2:bs_samples+1,not_data_cols+1: ...
% 			 not_data_cols+n_columns);
% if use_bca 
% 	jk_data  = bootstrap_log(bs_samples+2:bs_samples+jk_samples+1, ...
% 			 not_data_cols+1: not_data_cols+n_columns);
% end

% % Loop over the possible subsets
% ci = [];
% fignum = 1;
% for j = 1:b
%   % Only those subsets that have some runs are of interest (obviously)
%   if n_runs( j ) > 0 
%     row = 1;
%     col = 1;
%     [R,C] = find( use_rows(:,j) );

%     % Create subset
%     data = all_data(R,:);

%     lower = [];
%     upper = [];
%     % Calculate the confidence limits according to each method
%     if ( use_bca == 1 ) & ( n_runs(j) > percentile_bca_limit )
%       [lower, upper] = bca( orig_est, data, jk_data, ...
% 			    confidence_limits(1),  confidence_limits(2) );
%       ci = [ ci, [[combinations(:,j),combinations(:,j)];[ lower', upper']] ];
%     else
%       lower = prctile(data,confidence_limits(1),1);
%       upper = prctile(data,confidence_limits(2),1);
%       ci = [ ci, [[combinations(:,j),combinations(:,j)];[ lower', upper' ]] ];
%     end

%     % Loop over all parameters
%     for i = 1:n_columns,
%       if fixed_columns( i ) == 1 || same_columns( i ) == 1
% 	continue;
%       end
%       if col == (columns+1)
% 	col = 1;
% 	row = row + 1;
%       end
%       if row == (rows+1) || i == 1
% 	if i ~= 1
% 	  saveas( gcf, num2str(fignum), 'epsc2' );
%           fignum = fignum + 1;
%           close;
%         end
% 	h  = figure;
% 	col = 1;
% 	row = 1;
%       end
      
%       % Prepare plot
%       nplot = col+(row-1)*columns;
%       subplot(rows, columns, nplot);
      
%       % Create a histogram
%       hist(data(:,i),bars);
%       hold on;
      
%       ax = axis;

%       if col == 1 & row == 1
% 	x_text = ax(1) - (ax(2)-ax(1))*0.7;
% 	[c1,c2] = size(comb_names);
% 	for k = 1:c1
% 	  y_text = ax(4) + (ax(4)-ax(3))*(0.1*k);
% 	  text( x_text, y_text, comb_names(k,j) );
% 	end
%       end
	
%       % Add lines for the lower and upper confidence limits as they are
%       % determined by the bootstrap
%       h = line( [lower(i), lower(i)], ax(3:4) );
%       h = line( [upper(i), upper(i)], ax(3:4) );

%       % ----------- Add some text and figures ----------
  
%       % Upper likelihood-profiling confidence limit
%       y_text = ax(3) - (ax(4)-ax(3))*text_offset;
%       text( upper(i), y_text, num2str(upper(i)) );
      
%       % Lower likelihood-profiling confidence limit
%       text( lower(i), y_text, num2str(lower(i)) );
      
%       % Add a title to each plot
%       title( col_names( i, : ) );

%       hold off;
%       col = col + 1;
%     end
%     saveas( gcf, num2str(fignum), 'epsc2' );
%     fignum = fignum + 1;
%     close;
%   end
% end

% save 'matlab_ci.prn' ci -ascii;

		  




